#pragma warning(disable : 5208)
#define NOMINMAX

#include <limits>
#include <windows.h>
#include <mmsystem.h>
#include <iostream>
#include <string>
#include <stdio.h>
#include <math.h>
#include <vector> // STL dynamic memory.

// OpenGL includes
#include <GL/glew.h>
#include <GL/freeglut.h>

// Assimp includes
#include <assimp/cimport.h> // scene importer
#include <assimp/scene.h> // collects data
#include <assimp/postprocess.h> // various extra operations

// Project includes
#include "maths_funcs.h"

#include "glm/glm.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "glm/gtc/type_ptr.hpp"

#define GROUND "C:/Users/aogra/Desktop/mtass/mtass/ground.obj"
#define BODY "C:/Users/aogra/Desktop/mtass/mtass/spider_body.obj"
#define JOINT "C:/Users/aogra/Desktop/mtass/mtass/small_joint.obj"

//upper legs
#define LEFT_LEG_1 "C:/Users/aogra/Desktop/mtass/mtass/L1u.obj"
#define LEFT_LEG_2 "C:/Users/aogra/Desktop/mtass/mtass/L2u.obj"
#define LEFT_LEG_3 "C:/Users/aogra/Desktop/mtass/mtass/L3u.obj"
#define LEFT_LEG_4 "C:/Users/aogra/Desktop/mtass/mtass/L4u.obj"
#define RIGHT_LEG_1 "C:/Users/aogra/Desktop/mtass/mtass/R1u.obj"
#define RIGHT_LEG_2 "C:/Users/aogra/Desktop/mtass/mtass/R2u.obj"
#define RIGHT_LEG_3 "C:/Users/aogra/Desktop/mtass/mtass/R3u.obj"
#define RIGHT_LEG_4 "C:/Users/aogra/Desktop/mtass/mtass/R4u.obj"

//lower legs
#define LEFT_LEG_1l "C:/Users/aogra/Desktop/mtass/mtass/L1l.obj"
#define LEFT_LEG_2l "C:/Users/aogra/Desktop/mtass/mtass/L2l.obj"
#define LEFT_LEG_3l "C:/Users/aogra/Desktop/mtass/mtass/L3l.obj"
#define LEFT_LEG_4l "C:/Users/aogra/Desktop/mtass/mtass/L4l.obj"
#define RIGHT_LEG_1l "C:/Users/aogra/Desktop/mtass/mtass/R1l.obj"
#define RIGHT_LEG_2l "C:/Users/aogra/Desktop/mtass/mtass/R2l.obj"
#define RIGHT_LEG_3l "C:/Users/aogra/Desktop/mtass/mtass/R3l.obj"
#define RIGHT_LEG_4l "C:/Users/aogra/Desktop/mtass/mtass/R4l.obj"

typedef struct
{
	size_t mPointCount = 0;
	std::vector<vec3> mVertices;
	std::vector<vec3> mNormals;
	std::vector<vec2> mTextureCoords;
} ModelData;

using namespace std;

ModelData ground, body, joint, leg_1, leg_1l, leg_2, leg_2l, leg_3, leg_3l, leg_4, leg_4l,
							   leg_5, leg_5l, leg_6, leg_6l, leg_7, leg_7l, leg_8, leg_8l;

GLuint loc1, loc2, loc3;
GLuint vao0, vao1, vao2, vao2l, vao3, vao3l, vao4, vao4l, vao5, vao5l, vao6, vao6l,
								vao7, vao7l, vao8, vao8l, vao9, vao9l, vao10, vao10l;
				   

GLuint programID, floor_programID;
int width = 1000;
int height = 800;
int i = 0;

GLfloat translate_x = -12.0f;
GLfloat translate_y = 0.0f;
GLfloat translate_z = -12.0f;

GLfloat rotate_body = 0.0f;

GLfloat ry_j1 = 10.0f;
GLfloat ry_j2 = 0.0f;
GLfloat ry_j3 = 10.0f;
GLfloat ry_j4 = 0.0f;

GLfloat rz_j2 = 10.0f;
GLfloat rz_j3 = -10.0f;
GLfloat rz_j4 = -10.0f;
GLfloat rz_j5 = 10.0f;

GLfloat ry_j5 = 0.0f;
GLfloat ry_j6 = 0.0f;
GLfloat ry_j7 = 0.0f;
GLfloat ry_j8 = 0.0f;

GLfloat rl_j1 = 0.0f;
GLfloat rl_j2 = 0.0f;
GLfloat rl_j3 = 0.0f;
GLfloat rl_j4 = 0.0f;

GLfloat rl_j5 = 0.0f;
GLfloat rl_j6 = 0.0f;
GLfloat rl_j7 = 0.0f;
GLfloat rl_j8 = 0.0f;

GLfloat scale_x = 1.0f;
GLfloat scale_y = 1.0f;
GLfloat scale_z = 1.0f;

int projType = 0;

glm::vec3 cameraPos = glm::vec3(0.0f, 15.0f, 64.0f);
glm::vec3 cameraFront = glm::vec3(0.0f, -15.0f, -30.0f);
glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);

bool firstMouse = true;
GLfloat yaw = -90.0f;
GLfloat pitch = 0.0f;
float lastX = 800.0f / 2.0;
float lastY = 600.0f / 2.0;
float fov = 45.0f;

#pragma region MESH LOADING
/*----------------------------------------------------------------------------
MESH LOADING FUNCTION
----------------------------------------------------------------------------*/

ModelData load_mesh(const char* file_name) {
	ModelData modelData;

	/* Use assimp to read the model file, forcing it to be read as    */
	/* triangles. The second flag (aiProcess_PreTransformVertices) is */
	/* relevant if there are multiple meshes in the model file that   */
	/* are offset from the origin. This is pre-transform them so      */
	/* they're in the right position.                                 */
	const aiScene* scene = aiImportFile(
		file_name,
		aiProcess_Triangulate | aiProcess_PreTransformVertices
	);

	if (!scene) {
		fprintf(stderr, "ERROR: reading mesh %s\n", file_name);
		return modelData;
	}

	printf("  %i materials\n", scene->mNumMaterials);
	printf("  %i meshes\n", scene->mNumMeshes);
	printf("  %i textures\n", scene->mNumTextures);

	for (unsigned int m_i = 0; m_i < scene->mNumMeshes; m_i++) {
		const aiMesh* mesh = scene->mMeshes[m_i];
		printf("    %i vertices in mesh\n", mesh->mNumVertices);
		modelData.mPointCount += mesh->mNumVertices;

		for (unsigned int v_i = 0; v_i < mesh->mNumVertices; v_i++) {
			if (mesh->HasPositions()) {
				const aiVector3D* vp = &(mesh->mVertices[v_i]);
				modelData.mVertices.push_back(vec3(vp->x, vp->y, vp->z));
				
			}
			if (mesh->HasNormals()) {
				const aiVector3D* vn = &(mesh->mNormals[v_i]);
				modelData.mNormals.push_back(vec3(vn->x, vn->y, vn->z));
			}
			if (mesh->HasTextureCoords(0)) {
				const aiVector3D* vt = &(mesh->mTextureCoords[0][v_i]);
				modelData.mTextureCoords.push_back(vec2(vt->x, vt->y));
	
			}
			if (mesh->HasTangentsAndBitangents()) {
				/* You can extract tangents and bitangents here              */
				/* Note that you might need to make Assimp generate this     */
				/* data for you. Take a look at the flags that aiImportFile  */
				/* can take.                                                 */
			}
		}
	}

	aiReleaseImport(scene);
	return modelData;
}

#pragma endregion MESH LOADING

#pragma region READ SHADER
char* parseShader(const char* shaderFile) {
	FILE* sh;
	fopen_s(&sh, shaderFile, "rb");

	if (sh == NULL) { return NULL; }

	fseek(sh, 0L, SEEK_END);
	long size = ftell(sh);

	fseek(sh, 0L, SEEK_SET);
	char* buf = new char[size + 1];
	fread(buf, 1, size, sh);
	buf[size] = '\0';

	fclose(sh);

	return buf;
}
#pragma endregion READ SHADER

#pragma region SHADER FCNS
static void AddShader(GLuint ShaderProgram, const char* pShaderText, GLenum ShaderType) {
	// create a shader object
	GLuint ShaderObj = glCreateShader(ShaderType);

	if (ShaderObj == 0) {
		std::cerr << "Error creating shader..." << std::endl;
		std::cerr << "Press enter/return to exit..." << std::endl;
		std::cin.get();
		exit(1);
	}
	const char* pShaderSource = parseShader(pShaderText);

	// Bind the source code to the shader, this happens before compilation
	glShaderSource(ShaderObj, 1, (const GLchar**)&pShaderSource, NULL);
	// compile the shader and check for errors
	glCompileShader(ShaderObj);
	GLint success;
	// check for shader related errors using glGetShaderiv
	glGetShaderiv(ShaderObj, GL_COMPILE_STATUS, &success);
	if (!success) {
		GLchar InfoLog[1024] = { '\0' };
		glGetShaderInfoLog(ShaderObj, 1024, NULL, InfoLog);
		std::cerr << "Error compiling "
			<< (ShaderType == GL_VERTEX_SHADER ? "vertex" : "fragment")
			<< " shader program: " << InfoLog << std::endl;
		std::cerr << "Press enter/return to exit..." << std::endl;
		std::cin.get();
		exit(1);
	}
	// Attach the compiled shader object to the program object
	glAttachShader(ShaderProgram, ShaderObj);
}

GLuint compileShaders(int shaderID) {
	//Start the process of setting up our shaders by creating a program ID
	//Note: we will link all the shaders together into this ID
	GLuint progID = glCreateProgram();
	if (progID == 0) {
		std::cerr << "Error creating shader program..." << std::endl;
		std::cerr << "Press enter/return to exit..." << std::endl;
		std::cin.get();
		exit(1);
	}

	if (shaderID == 0) {
		AddShader(progID, "C:/Users/aogra/Desktop/mtass/mtass/vertexShader.txt", GL_VERTEX_SHADER);
		AddShader(progID, "C:/Users/aogra/Desktop/mtass/mtass/fragmentShader.txt", GL_FRAGMENT_SHADER);
	}
	
	else {
		AddShader(progID, "C:/Users/aogra/Desktop/mtass/mtass/floor_vs.txt", GL_VERTEX_SHADER);
		AddShader(progID, "C:/Users/aogra/Desktop/mtass/mtass/floor_fs.txt", GL_FRAGMENT_SHADER);
	}

	GLint Success = 0;
	GLchar ErrorLog[1024] = { '\0' };
	// After compiling all shader objects and attaching them to the program, we can finally link it
	glLinkProgram(progID);
	// check for program related errors using glGetProgramiv
	glGetProgramiv(progID, GL_LINK_STATUS, &Success);
	if (Success == 0) {
		glGetProgramInfoLog(progID, sizeof(ErrorLog), NULL, ErrorLog);
		std::cerr << "Error linking shader program: " << ErrorLog << std::endl;
		std::cerr << "Press enter/return to exit..." << std::endl;
		std::cin.get();
		exit(1);
	}

	// program has been successfully linked but needs to be validated to check whether the program can execute given the current pipeline state
	glValidateProgram(progID);
	// check for program related errors using glGetProgramiv
	glGetProgramiv(progID, GL_VALIDATE_STATUS, &Success);
	if (!Success) {
		glGetProgramInfoLog(progID, sizeof(ErrorLog), NULL, ErrorLog);
		std::cerr << "Invalid shader program: " << ErrorLog << std::endl;
		std::cerr << "Press enter/return to exit..." << std::endl;
		std::cin.get();
		exit(1);
	}
	// Finally, use the linked shader program
	// Note: this program will stay in effect for all draw calls until you replace it with another or explicitly disable its use
	glUseProgram(progID);
	return progID;
}
#pragma endregion SHADER FCNS

#pragma region VBO_FUNCTIONS
void generateObjectBufferMesh(GLuint vao, ModelData mesh_data) {
	/*----------------------------------------------------------------------------
	LOAD MESH HERE AND COPY INTO BUFFERS
	----------------------------------------------------------------------------*/

	//Note: you may get an error "vector subscript out of range" if you are using this code for a mesh that doesnt have positions and normals
	//Might be an idea to do a check for that before generating and binding the buffer.

	unsigned int vp_vbo = 0;
	unsigned int vn_vbo = 0;

	//mesh 1
	loc1 = glGetAttribLocation(programID, "vertex_position");
	loc2 = glGetAttribLocation(programID, "vertex_normal");
	loc3 = glGetAttribLocation(programID, "vertex_texture");

	glGenBuffers(1, &vp_vbo);
	glBindBuffer(GL_ARRAY_BUFFER, vp_vbo);
	glBufferData(GL_ARRAY_BUFFER, mesh_data.mPointCount * sizeof(vec3), &mesh_data.mVertices[0], GL_STATIC_DRAW);

	glGenBuffers(1, &vn_vbo);
	glBindBuffer(GL_ARRAY_BUFFER, vn_vbo);
	glBufferData(GL_ARRAY_BUFFER, mesh_data.mPointCount * sizeof(vec3), &mesh_data.mNormals[0], GL_STATIC_DRAW);

	glBindVertexArray(vao);

	glEnableVertexAttribArray(loc1);
	glBindBuffer(GL_ARRAY_BUFFER, vp_vbo);
	glVertexAttribPointer(loc1, 3, GL_FLOAT, GL_FALSE, 0, NULL);

	glEnableVertexAttribArray(loc2);
	glBindBuffer(GL_ARRAY_BUFFER, vn_vbo);
	glVertexAttribPointer(loc2, 3, GL_FLOAT, GL_FALSE, 0, NULL);

}
#pragma endregion VBO_FUNCTIONS


void display() {

	// tell GL to only draw onto a pixel if the shape is closer to the viewer
	glEnable(GL_DEPTH_TEST); // enable depth-testing
	glDepthFunc(GL_LESS); // depth-testing interprets a smaller value as "closer"
	glClearColor(0.4f, 0.4f, 0.4f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	//setting up projection matrix
	glm::mat4 persp_proj = glm::perspective(glm::radians(fov), (float)width / (float)height, 1.0f, 100.0f);
	if (projType == 0) {
		persp_proj = glm::perspective(45.0f, (float)width / (float)height, 1.0f, 100.0f);
	}

	else if (projType == 1) {
		persp_proj = glm::ortho(-16.0f, 16.0f, -12.0f, 12.0f, 1.0f, 100.0f);
	}

	//setting up camera
	//lookAt(position, target, up vector);
	glm::mat4 view = glm::mat4(1.0f);
	view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);

	glUseProgram(floor_programID);
	int floor_matrix_location = glGetUniformLocation(floor_programID, "model");
	int floor_view_mat_location = glGetUniformLocation(floor_programID, "view");
	int floor_proj_mat_location = glGetUniformLocation(floor_programID, "proj");

	//floor
	glm::mat4 gnd = glm::mat4(1.0f);
	glUniformMatrix4fv(floor_matrix_location, 1, GL_FALSE, glm::value_ptr(gnd));
	glUniformMatrix4fv(floor_proj_mat_location, 1, GL_FALSE, glm::value_ptr(persp_proj));
	glUniformMatrix4fv(floor_view_mat_location, 1, GL_FALSE, glm::value_ptr(view));
	glBindVertexArray(vao0);
	glDrawArrays(GL_TRIANGLES, 0, ground.mPointCount);
	
	glUseProgram(programID);
	int matrix_location = glGetUniformLocation(programID, "model");
	int view_mat_location = glGetUniformLocation(programID, "view");
	int proj_mat_location = glGetUniformLocation(programID, "proj");

	glUniformMatrix4fv(proj_mat_location, 1, GL_FALSE, glm::value_ptr(persp_proj));
	glUniformMatrix4fv(view_mat_location, 1, GL_FALSE, glm::value_ptr(view));

	//body of spider (root)
	glm::mat4 model = glm::mat4(1.0f);
	glm::mat4 R = glm::mat4(1.0f);
	glm::mat4 T = glm::mat4(1.0f);
	T = glm::translate(glm::mat4(1.0f), glm::vec3(translate_x, translate_y, translate_z));
	R = glm::rotate(glm::mat4(1.0f), rotate_body, glm::vec3(0.0f, 1.0f, 0.0f));
	model = glm::scale(glm::mat4(1.0f), glm::vec3(scale_x, scale_y, scale_z));
	model = T * R * model;

	glm::mat4 global = model;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global));
	glBindVertexArray(vao1);
	glDrawArrays(GL_TRIANGLES, 0, body.mPointCount);

#pragma region LEFT LEGS
	//joint 1
	glm::mat4 joint1 = glm::mat4(1.0f);
	glm::mat4 Rj1 = glm::mat4(1.0f);
	glm::mat4 Tj1 = glm::mat4(1.0f);
	Rj1 = glm::rotate(glm::mat4(1.0f), ry_j1, glm::vec3(1.0f, 0.0f, 0.0f));
	Tj1 = glm::translate(glm::mat4(1.0f), glm::vec3(-0.6f, 1.85f, 0.2f));
	joint1 = Tj1 * Rj1;

	glm::mat4 global0 = model * joint1;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global0));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	//leg 1
	glm::mat4 leg1 = glm::mat4(1.0f);
	leg1 = glm::translate(glm::mat4(1.0f), glm::vec3(0.6f, -1.85f, -0.2f));
	
	glm::mat4 global1 = model * joint1 * leg1;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global1));
	glBindVertexArray(vao2);
	glDrawArrays(GL_TRIANGLES, 0, leg_1.mPointCount);

	//lower joint 1
	glm::mat4 joint1l = glm::mat4(1.0f);
	glm::mat4 Rj1l = glm::mat4(1.0f);
	glm::mat4 Tj1l = glm::mat4(1.0f);
	Rj1l = glm::rotate(glm::mat4(1.0f), rl_j1, glm::vec3(1.0f, 0.0f, 0.0f));
	Tj1l = glm::translate(glm::mat4(1.0f), glm::vec3(-0.15f, 2.9f, 1.8f));
	joint1l = Tj1l * Rj1l;

	glm::mat4 global0l = model * joint1 * leg1 * joint1l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global0l));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	//lower leg 1
	glm::mat4 leg1l = glm::mat4(1.0f);
	leg1l = glm::translate(glm::mat4(1.0f), glm::vec3(0.15f, -2.9f, -1.8f));

	glm::mat4 global1l = model * joint1 * leg1 * joint1l * leg1l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global1l));
	glBindVertexArray(vao2l);
	glDrawArrays(GL_TRIANGLES, 0, leg_1l.mPointCount);

	/*********************************************************************************************/

	//joint 2
	glm::mat4 joint2 = glm::mat4(1.0f);
	glm::mat4 Rj2 = glm::mat4(1.0f);
	glm::mat4 Ry2 = glm::mat4(1.0f);
	glm::mat4 Tj2 = glm::mat4(1.0f);
	Ry2 = glm::rotate(glm::mat4(1.0f), rz_j2, glm::vec3(0.0f, 1.0f, 0.0f));
	Rj2 = glm::rotate(glm::mat4(1.0f), ry_j2, glm::vec3(0.0f, 0.0f, 1.0f));
	Tj2 = glm::translate(glm::mat4(1.0f), glm::vec3(-0.6f, 1.85f, -0.2f));
	joint2 = Tj2 * Rj2 * Ry2;

	glm::mat4 global2 = model * joint2;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global2));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	//leg 2
	glm::mat4 leg2 = glm::mat4(1.0f);
	leg2 = glm::translate(glm::mat4(1.0f), glm::vec3(0.6f, -1.85f, 0.2f));

	glm::mat4 global3 = model * joint2 * leg2;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global3));
	glBindVertexArray(vao3);
	glDrawArrays(GL_TRIANGLES, 0, leg_2.mPointCount);

	//lower joint 2
	glm::mat4 joint2l = glm::mat4(1.0f);
	glm::mat4 Rj2l = glm::mat4(1.0f);
	glm::mat4 Tj2l = glm::mat4(1.0f);
	Rj2l = glm::rotate(glm::mat4(1.0f), rl_j2, glm::vec3(0.0f, 0.0f, 1.0f));
	Tj2l = glm::translate(glm::mat4(1.0f), glm::vec3(0.35f, 3.25f, 0.57f));
	joint2l = Tj2l * Rj2l;

	glm::mat4 global2l = model * joint2 * leg2 * joint2l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global2l));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	//lower leg 2
	glm::mat4 leg2l = glm::mat4(1.0f);
	leg2l = glm::translate(glm::mat4(1.0f), glm::vec3(-0.35f, -3.25f, -0.57f));

	glm::mat4 global3l = model * joint2 * leg2 * joint2l * leg2l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global3l));
	glBindVertexArray(vao3l);
	glDrawArrays(GL_TRIANGLES, 0, leg_2l.mPointCount);

	/*********************************************************************************************/

	//joint 3
	glm::mat4 joint3 = glm::mat4(1.0f);
	glm::mat4 Rj3 = glm::mat4(1.0f);
	glm::mat4 Ry3 = glm::mat4(1.0f);
	glm::mat4 Tj3 = glm::mat4(1.0f);
	Ry3 = glm::rotate(glm::mat4(1.0f), rz_j3, glm::vec3(0.0f, 1.0f, 0.0f));
	Rj3 = glm::rotate(glm::mat4(1.0f), ry_j3, glm::vec3(0.0f, 0.0f, 1.0f));
	Tj3 = glm::translate(glm::mat4(1.0f), glm::vec3(-0.6f, 1.85f, -0.55f));
	joint3 = Tj3 * Rj3 * Ry3;

	glm::mat4 global4 = model * joint3;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global4));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	//leg 3
	glm::mat4 leg3 = glm::mat4(1.0f);
	leg3 = glm::translate(glm::mat4(1.0f), glm::vec3(0.6f, -1.85f, 0.55f));
	
	glm::mat4 global5 = model * joint3 * leg3;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global5));
	glBindVertexArray(vao4);
	glDrawArrays(GL_TRIANGLES, 0, leg_3.mPointCount);

	// lower joint 3
	glm::mat4 joint3l = glm::mat4(1.0f);
	glm::mat4 Rj3l = glm::mat4(1.0f);
	glm::mat4 Tj3l = glm::mat4(1.0f);
	Rj3l = glm::rotate(glm::mat4(1.0f), rl_j3, glm::vec3(0.0f, 0.0f, 1.0f));
	Tj3l = glm::translate(glm::mat4(1.0f), glm::vec3(0.89f, 3.55f, -1.06f));
	joint3l = Tj3l * Rj3l;

	glm::mat4 global4l = model * joint3 * leg3 * joint3l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global4l));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	// lower leg 3
	glm::mat4 leg3l = glm::mat4(1.0f);
	leg3l = glm::translate(glm::mat4(1.0f), glm::vec3(-0.89f, -3.55f, 1.06f));

	glm::mat4 global5l = model * joint3 * leg3 * joint3l * leg3l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global5l));
	glBindVertexArray(vao4l);
	glDrawArrays(GL_TRIANGLES, 0, leg_3l.mPointCount);

	/*********************************************************************************************/

	//joint 4
	glm::mat4 joint4 = glm::mat4(1.0f);
	glm::mat4 Rj4 = glm::mat4(1.0f);
	glm::mat4 Tj4 = glm::mat4(1.0f);
	Rj4 = glm::rotate(glm::mat4(1.0f), ry_j4, glm::vec3(1.0f, 0.0f, 0.0f));
	Tj4 = glm::translate(glm::mat4(1.0f), glm::vec3(-0.6f, 1.85f, -0.8f));
	joint4 = Tj4 * Rj4;

	glm::mat4 global6 = model * joint4;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global6));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	//leg 4
	glm::mat4 leg4 = glm::mat4(1.0f);
	leg4 = glm::translate(glm::mat4(1.0f), glm::vec3(0.6f, -1.85f, 0.8f));

	glm::mat4 global7 = model * joint4 * leg4;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global7));
	glBindVertexArray(vao5);
	glDrawArrays(GL_TRIANGLES, 0, leg_4.mPointCount);

	// lower joint 4
	glm::mat4 joint4l = glm::mat4(1.0f);
	glm::mat4 Rj4l = glm::mat4(1.0f);
	glm::mat4 Tj4l = glm::mat4(1.0f);
	Rj4l = glm::rotate(glm::mat4(1.0f), rl_j4, glm::vec3(1.0f, 0.0f, 0.0f));
	Tj4l = glm::translate(glm::mat4(1.0f), glm::vec3(-0.12f, 4.27f, -1.9f));
	joint4l = Tj4l * Rj4l;

	glm::mat4 global6l = model * joint4 * leg4 * joint4l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global6l));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	// lower leg 4
	glm::mat4 leg4l = glm::mat4(1.0f);
	leg4l = glm::translate(glm::mat4(1.0f), glm::vec3(0.12f, -4.27f, 1.9f));

	glm::mat4 global7l = model * joint4 * leg4 * joint4l * leg4l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global7l));
	glBindVertexArray(vao5l);
	glDrawArrays(GL_TRIANGLES, 0, leg_4l.mPointCount);
#pragma endregion LEFT LEGS
	
#pragma region RIGHT LEGS
	//joint 5
	glm::mat4 joint5 = glm::mat4(1.0f);
	glm::mat4 Rj5 = glm::mat4(1.0f);
	glm::mat4 Tj5 = glm::mat4(1.0f);
	Rj5 = glm::rotate(glm::mat4(1.0f), ry_j5, glm::vec3(1.0f, 0.0f, 0.0f));
	Tj5 = glm::translate(glm::mat4(1.0f), glm::vec3(-1.35f, 1.85f, 0.2f));
	joint5 = Tj5 * Rj5;

	glm::mat4 global8 = model * joint5;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global8));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	//leg 5
	glm::mat4 leg5 = glm::mat4(1.0f);
	leg5 = glm::translate(glm::mat4(1.0f), glm::vec3(1.35f, -1.85f, -0.2f));
	
	glm::mat4 global9 = model * joint5 * leg5;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global9));
	glBindVertexArray(vao6);
	glDrawArrays(GL_TRIANGLES, 0, leg_5.mPointCount);

	// lower joint 5
	glm::mat4 joint5l = glm::mat4(1.0f);
	glm::mat4 Rj5l = glm::mat4(1.0f);
	glm::mat4 Tj5l = glm::mat4(1.0f);
	Rj5l = glm::rotate(glm::mat4(1.0f), rl_j5, glm::vec3(1.0f, 0.0f, 0.0f));
	Tj5l = glm::translate(glm::mat4(1.0f), glm::vec3(-1.78f, 2.9f, 1.8f));
	joint5l = Tj5l * Rj5l;

	glm::mat4 global8l = model * joint5 * leg5 * joint5l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global8l));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	// lower leg 5
	glm::mat4 leg5l = glm::mat4(1.0f);
	leg5l = glm::translate(glm::mat4(1.0f), glm::vec3(1.78f, -2.9f, -1.8f));

	glm::mat4 global9l = model * joint5 * leg5 * joint5l * leg5l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global9l));
	glBindVertexArray(vao6l);
	glDrawArrays(GL_TRIANGLES, 0, leg_5l.mPointCount);

	/*********************************************************************************************/

	//joint 6
	glm::mat4 joint6 = glm::mat4(1.0f);
	glm::mat4 Rj6 = glm::mat4(1.0f);
	glm::mat4 Ry6 = glm::mat4(1.0f);
	glm::mat4 Tj6 = glm::mat4(1.0f);
	Ry6 = glm::rotate(glm::mat4(1.0f), rz_j4, glm::vec3(0.0f, 1.0f, 0.0f));
	Rj6 = glm::rotate(glm::mat4(1.0f), ry_j6, glm::vec3(0.0f, 0.0f, 1.0f));
	Tj6 = glm::translate(glm::mat4(1.0f), glm::vec3(-1.35f, 1.85f, -0.2f));
	joint6 = Tj6 * Rj6 * Ry6;

	glm::mat4 global10 = model * joint6;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global10));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	//leg 6
	glm::mat4 leg6 = glm::mat4(1.0f);
	leg6 = glm::translate(glm::mat4(1.0f), glm::vec3(1.35f, -1.85f, 0.2f));
	
	glm::mat4 global11 = model * joint6 * leg6;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global11));
	glBindVertexArray(vao7);
	glDrawArrays(GL_TRIANGLES, 0, leg_6.mPointCount);

	// lower joint 6
	glm::mat4 joint6l = glm::mat4(1.0f);
	glm::mat4 Rj6l = glm::mat4(1.0f);
	glm::mat4 Tj6l = glm::mat4(1.0f);
	Rj6l = glm::rotate(glm::mat4(1.0f), rl_j6, glm::vec3(0.0f, 0.0f, 1.0f));
	Tj6l = glm::translate(glm::mat4(1.0f), glm::vec3(-2.27f, 3.25f, 0.57f));
	joint6l = Tj6l * Rj6l;

	glm::mat4 global10l = model * joint6 * leg6 * joint6l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global10l));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	// lower leg 6
	glm::mat4 leg6l = glm::mat4(1.0f);
	leg6l = glm::translate(glm::mat4(1.0f), glm::vec3(2.27f, -3.25f, -0.57f));

	glm::mat4 global11l = model * joint6 * leg6 * joint6l * leg6l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global11l));
	glBindVertexArray(vao7l);
	glDrawArrays(GL_TRIANGLES, 0, leg_6l.mPointCount);

	/*********************************************************************************************/

	//joint 7
	glm::mat4 joint7 = glm::mat4(1.0f);
	glm::mat4 Rj7 = glm::mat4(1.0f);
	glm::mat4 Ry7 = glm::mat4(1.0f);
	glm::mat4 Tj7 = glm::mat4(1.0f);
	Ry7 = glm::rotate(glm::mat4(1.0f), rz_j5, glm::vec3(0.0f, 1.0f, 0.0f));
	Rj7 = glm::rotate(glm::mat4(1.0f), ry_j7, glm::vec3(0.0f, 0.0f, 1.0f));
	Tj7 = glm::translate(glm::mat4(1.0f), glm::vec3(-1.35f, 1.85f, -0.55f));
	joint7 = Tj7 * Rj7 * Ry7;

	glm::mat4 global12 = model * joint7;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global12));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	//leg 7
	glm::mat4 leg7 = glm::mat4(1.0f);
	leg7 = glm::translate(glm::mat4(1.0f), glm::vec3(1.35f, -1.85f, 0.55f));
	
	glm::mat4 global13 = model * joint7 * leg7;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global13));
	glBindVertexArray(vao9);
	glDrawArrays(GL_TRIANGLES, 0, leg_7.mPointCount);

	// lower joint 7
	glm::mat4 joint7l = glm::mat4(1.0f);
	glm::mat4 Rj7l = glm::mat4(1.0f);
	glm::mat4 Tj7l = glm::mat4(1.0f);
	Rj7l = glm::rotate(glm::mat4(1.0f), rl_j7, glm::vec3(0.0f, 0.0f, 1.0f));
	Tj7l = glm::translate(glm::mat4(1.0f), glm::vec3(-2.82f, 3.55f, -1.06f));
	joint7l = Tj7l * Rj7l;

	glm::mat4 global12l = model * joint7 * leg7 * joint7l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global12l));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	// lower leg 7
	glm::mat4 leg7l = glm::mat4(1.0f);
	leg7l = glm::translate(glm::mat4(1.0f), glm::vec3(2.82f, -3.55f, 1.06f));

	glm::mat4 global13l = model * joint7 * leg7 * joint7l * leg7l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global13l));
	glBindVertexArray(vao9l);
	glDrawArrays(GL_TRIANGLES, 0, leg_7l.mPointCount);

	/*********************************************************************************************/

	//joint 8
	glm::mat4 joint8 = glm::mat4(1.0f);
	glm::mat4 Rj8 = glm::mat4(1.0f);
	glm::mat4 Tj8 = glm::mat4(1.0f);
	Rj8 = glm::rotate(glm::mat4(1.0f), ry_j8, glm::vec3(1.0f, 0.0f, 0.0f));
	Tj8 = glm::translate(glm::mat4(1.0f), glm::vec3(-1.35f, 1.85f, -0.8f));
	joint8 = Tj8 * Rj8;

	glm::mat4 global14 = model * joint8;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global14));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	//leg 8
	glm::mat4 leg8 = glm::mat4(1.0f);
	leg8 = glm::translate(glm::mat4(1.0f), glm::vec3(1.35f, -1.85f, 0.8f));

	glm::mat4 global15 = model * joint8 * leg8;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global15));
	glBindVertexArray(vao10);
	glDrawArrays(GL_TRIANGLES, 0, leg_8.mPointCount);

	// lower joint 8
	glm::mat4 joint8l = glm::mat4(1.0f);
	glm::mat4 Rj8l = glm::mat4(1.0f);
	glm::mat4 Tj8l = glm::mat4(1.0f);
	Rj8l = glm::rotate(glm::mat4(1.0f), rl_j8, glm::vec3(1.0f, 0.0f, 0.0f));
	Tj8l = glm::translate(glm::mat4(1.0f), glm::vec3(-1.8f, 4.27f, -1.9f));
	joint8l = Tj8l * Rj8l;

	glm::mat4 global14l = model * joint8 * leg8 * joint8l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global14l));
	glBindVertexArray(vao8);
	glDrawArrays(GL_TRIANGLES, 0, joint.mPointCount);

	// lower leg 8
	glm::mat4 leg8l = glm::mat4(1.0f);
	leg8l = glm::translate(glm::mat4(1.0f), glm::vec3(1.8f, -4.27f, 1.9f));

	glm::mat4 global15l = model * joint8 * leg8 * joint8l * leg8l;
	glUniformMatrix4fv(matrix_location, 1, GL_FALSE, glm::value_ptr(global15l));
	glBindVertexArray(vao10l);
	glDrawArrays(GL_TRIANGLES, 0, leg_8l.mPointCount);
#pragma endregion RIGHT LEGS

	glutSwapBuffers();
}


bool first_time = true;
bool backwards = true;
static void updateScene(int value) {
	
	if (backwards) {
		translate_y += 0.05f;

		rz_j2 = 0.0f;
		rz_j3 = 15.0f;
		rz_j4 = 0.0f;
		rz_j5 = 15.0f;


		ry_j1 -= 10.0f;
		ry_j2 += 10.0f;
		ry_j3 -= 10.0f;
		ry_j4 += 10.0f;

		rl_j1 = 0.0f;
		rl_j2 = 0.0f;
		rl_j3 = 10.0f;
		rl_j4 = 0.0f;

		ry_j5 += 10.0f;
		ry_j6 -= 10.0f;
		ry_j7 += 10.0f;
		ry_j8 -= 10.0f;

		rl_j5 = -40.0f;
		rl_j6 = 0.0f;
		rl_j7 = -10.0f;
		rl_j8 = 20.0f;

		backwards = false;
	}

	else {
		translate_y -= 0.05f;

		rz_j2 = 15.0f;
		rz_j3 = 0.0f;
		rz_j4 = 15.0f;
		rz_j5 = 0.0f;


		ry_j1 += 10.0f;
		ry_j2 -= 10.0f;
		ry_j3 += 10.0f;
		ry_j4 -= 10.0f;

		rl_j1 = -40.0f;
		rl_j2 = 10.0f;
		rl_j3 = 0.0f;
		rl_j4 = 20.0f;

		ry_j5 -= 10.0f;
		ry_j6 += 10.0f;
		ry_j7 -= 10.0f;
		ry_j8 += 10.0f;

		rl_j5 = 0.0f;
		rl_j6 = -10.0f;
		rl_j7 = 0.0f;
		rl_j8 = 0.0f;

		backwards = true;
	}
	
	if (translate_x == -12.0f && -12.0f <= translate_z < 12.0f) {

		if (!first_time) {
			rotate_body = 360.0f;
		}

		translate_z += 1.0f;
		first_time = false;
	}

	if (translate_z == 12.0f && -12.0f <= translate_x < 12.0f) {
		rotate_body = 90.0f;
		translate_x += 1.0f;
	}

	if (translate_x == 12.0f && -12.0f < translate_z <= 12.0f) {
		rotate_body = 180.0f;
		translate_z -= 1.0f;
	}

	if (translate_z == -12.0f && -12.0f < translate_x <= 12.0f) {
		rotate_body = 270.0f;
		translate_x -= 1.0f;
	}
	
	// Draw the next frame

	glutPostRedisplay();
	glutTimerFunc(175, updateScene, 0);
}

void init() {

	// Set up the shaders
	programID = compileShaders(0);
	floor_programID = compileShaders(1);
	// load mesh into a vertex buffer array

	ground = load_mesh(GROUND);
	glGenVertexArrays(1, &vao0);
	generateObjectBufferMesh(vao0, ground);

	joint = load_mesh(JOINT);
	glGenVertexArrays(1, &vao8);
	generateObjectBufferMesh(vao8, joint);

	body = load_mesh(BODY);
	glGenVertexArrays(1, &vao1);
	generateObjectBufferMesh(vao1, body);


	leg_1 = load_mesh(LEFT_LEG_1);
	glGenVertexArrays(1, &vao2);
	generateObjectBufferMesh(vao2, leg_1);

	leg_1l = load_mesh(LEFT_LEG_1l);
	glGenVertexArrays(1, &vao2l);
	generateObjectBufferMesh(vao2l, leg_1l);

	leg_2 = load_mesh(LEFT_LEG_2);
	glGenVertexArrays(1, &vao3);
	generateObjectBufferMesh(vao3, leg_2);

	leg_2l = load_mesh(LEFT_LEG_2l);
	glGenVertexArrays(1, &vao3l);
	generateObjectBufferMesh(vao3l, leg_2l);

	leg_3 = load_mesh(LEFT_LEG_3);
	glGenVertexArrays(1, &vao4);
	generateObjectBufferMesh(vao4, leg_3);

	leg_3l = load_mesh(LEFT_LEG_3l);
	glGenVertexArrays(1, &vao4l);
	generateObjectBufferMesh(vao4l, leg_3l);

	leg_4 = load_mesh(LEFT_LEG_4);
	glGenVertexArrays(1, &vao5);
	generateObjectBufferMesh(vao5, leg_4);

	leg_4l = load_mesh(LEFT_LEG_4l);
	glGenVertexArrays(1, &vao5l);
	generateObjectBufferMesh(vao5l, leg_4l);

	leg_5 = load_mesh(RIGHT_LEG_1);
	glGenVertexArrays(1, &vao6);
	generateObjectBufferMesh(vao6, leg_5);

	leg_5l = load_mesh(RIGHT_LEG_1l);
	glGenVertexArrays(1, &vao6l);
	generateObjectBufferMesh(vao6l, leg_5l);

	leg_6 = load_mesh(RIGHT_LEG_2);
	glGenVertexArrays(1, &vao7);
	generateObjectBufferMesh(vao7, leg_6);

	leg_6l = load_mesh(RIGHT_LEG_2l);
	glGenVertexArrays(1, &vao7l);
	generateObjectBufferMesh(vao7l, leg_6l);

	leg_7 = load_mesh(RIGHT_LEG_3);
	glGenVertexArrays(1, &vao9);
	generateObjectBufferMesh(vao9, leg_7);

	leg_7l = load_mesh(RIGHT_LEG_3l);
	glGenVertexArrays(1, &vao9l);
	generateObjectBufferMesh(vao9l, leg_7l);

	leg_8 = load_mesh(RIGHT_LEG_4);
	glGenVertexArrays(1, &vao10);
	generateObjectBufferMesh(vao10, leg_8);

	leg_8l = load_mesh(RIGHT_LEG_4l);
	glGenVertexArrays(1, &vao10l);
	generateObjectBufferMesh(vao10l, leg_8l);

}

void keypress(unsigned char key, int x, int y) {

	switch (key) {
	case 'y':
		translate_y += 2.0f;
		break;
	case 'h':
		rl_j1 += 2.0f;
		break;
	case 'j':
		rl_j1 -= 2.0f;

	case 'p':
		projType = 0;
		break;
	case 'o':
		projType = 1;
		break;


	case 'z':
		cameraPos += glm::vec3(0.0f, 0.0f, 2.0f);
		break;
	case 'x':
		cameraPos -= glm::vec3(0.0f, 0.0f, 2.0f);
		break;
	case 'w':
		cameraPos += glm::vec3(0.0f, 2.0f, 0.0f);
		break;
	case 's':
		cameraPos -= glm::vec3(0.0f, 2.0f, 0.0f);
		break;
	case 'a':
		cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp));
		break;
	case 'd':
		cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp));
		break;
	}

	glutPostRedisplay();
}

void mouseclick(int xpos, int ypos) {
	
	if (firstMouse)
	{
		lastX = xpos;
		lastY = ypos;
		firstMouse = false;
	}

	float xoffset = xpos - lastX;
	float yoffset = lastY - ypos;
	lastX = xpos;
	lastY = ypos;

	float sensitivity = 0.1f;
	xoffset *= sensitivity;
	yoffset *= sensitivity;

	yaw += xoffset;
	pitch += yoffset;

	if (pitch > 89.0f)
		pitch = 89.0f;
	if (pitch < -89.0f)
		pitch = -89.0f;

	glm::vec3 direction;
	direction.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
	direction.y = sin(glm::radians(pitch));
	direction.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
	cameraFront = glm::normalize(direction);
}

int main(int argc, char** argv) {

	// Set up the window
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
	glutInitWindowSize(width, height);
	glutCreateWindow("Hello Triangle");

	// Tell glut where the display function is
	glutDisplayFunc(display);
	//glutIdleFunc(updateScene);
	glutKeyboardFunc(keypress);
	glutPassiveMotionFunc(mouseclick);

	// A call to glewInit() must be done after glut is initialized!
	GLenum res = glewInit();
	// Check for any errors
	if (res != GLEW_OK) {
		fprintf(stderr, "Error: '%s'\n", glewGetErrorString(res));
		return 1;
	}

	// Set up your objects and shaders
	init();

	updateScene(0);
	glutMainLoop();

	return 0;
}